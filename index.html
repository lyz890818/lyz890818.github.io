<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="Windmill&#39;s Notes">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Windmill&#39;s Notes">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Windmill&#39;s Notes">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Windmill's Notes</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Windmill's Notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/23/iOS-Objective-C面试题总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="行走的风车">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Windmill's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/23/iOS-Objective-C面试题总结/" itemprop="url">iOS Objective-C面试题总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-23T22:37:59+08:00">
                2017-06-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="Git-工作流程"><a href="#Git-工作流程" class="headerlink" title="Git 工作流程"></a>Git 工作流程</h4><ol>
<li>使用中央服务器辅助协作；  </li>
<li>每人在服务器拥有一个以自己 id 为名称的分支；  </li>
<li>各人只许推送更新到自己的分支，不允许推送到别人的分支或者 master；</li>
<li>master 由专人管理，在合适时 merge 其它分支（开发初期每日自动 merge 各人分支，生产化后则由人工 merge 经过 review 的分支）；</li>
<li>代码修改 merge 到 master 后，将同步到所有终端。</li>
</ol>
<hr>
<h4 id="关于instrument"><a href="#关于instrument" class="headerlink" title="关于instrument"></a>关于instrument</h4><ol>
<li>Time Profiler:性能分析</li>
<li>Zombies:检查是否访问了僵尸对象,但是这个工具只能从上往下检查,不智能</li>
<li>Allocations:用来检查内存,写算法的那批人也用这个来检查</li>
<li>Leaks:检查内存,看是否有内存泄露</li>
</ol>
<hr>
<h4 id="如何调试BAD-ACCESS错误"><a href="#如何调试BAD-ACCESS错误" class="headerlink" title="如何调试BAD_ACCESS错误"></a>如何调试BAD_ACCESS错误</h4><ol>
<li>重写object的respondsToSelector方法，现实出现EXEC_BAD_ACCESS前访问的最后一个object。</li>
<li>EXC_BAD_ACCESS 这个错误，可以这么说，90%的错误来源在于对一个已经释放的对象进行release操作。</li>
</ol>
<hr>
<h4 id="您开发常用的工具有哪些？"><a href="#您开发常用的工具有哪些？" class="headerlink" title="您开发常用的工具有哪些？"></a>您开发常用的工具有哪些？</h4><ol>
<li>友盟统计</li>
<li>青花瓷charles:这个软件还是蛮不错的,可以用来过滤网络请求,模拟低速网路,还可以修改网络请求内容这些</li>
<li>Reveal:调试页面不错,还有用来学习别人的demo时候可以拿来看UI层次结构,还可以用来标记可以设为透明的控件,用来优化性能</li>
<li>马克鳗</li>
<li>Photoshop</li>
<li>Frank DeLoupe: 支持 Retina 的屏幕拾色器，吐血推荐 Frank DeLoupe</li>
<li>xScope: 每个前端工程师心中都有一把尺子 xScope</li>
<li>Synergy: 在多台电脑间共享键盘和鼠标，只有一个系统一台显示器的前端工程师不是好厨子 Synergy</li>
<li>Kaleidoscope: 最好用的 Diff 工具，没有之一 Kaleidoscope</li>
<li>iA Writer: Markdown 写文档的工具，开始写文档的那天就是一个前端工程师走向成熟的标志 iA Writer for Mac</li>
<li>Tower: Git 的 GUI 工具，支持 GitHub，而且比 GitHub 自己的客户端功能要强大，推荐使用 Git 又对 terminal 命令没有强迫症的人使用 Tower - The most powerful Git client for Mac</li>
<li>Dash: 各种语言和工具、框架的文档 <a href="https://itunes.apple.com/us/app/dash-docs-snippets/id458034879?mt=12" target="_blank" rel="external">https://itunes.apple.com/us/app/dash-docs-snippets/id458034879?mt=12</a></li>
</ol>
<hr>
<h4 id="iOS-的签名机制大概是怎样的？"><a href="#iOS-的签名机制大概是怎样的？" class="headerlink" title="iOS 的签名机制大概是怎样的？"></a>iOS 的签名机制大概是怎样的？</h4><p>签名机制：</p>
<ol>
<li>先将应用内容通过摘要算法，得到摘要</li>
<li>再用私钥对摘要进行加密得到密文</li>
<li>将源文本、密文、和私钥对应的公钥一并发布</li>
</ol>
<p>验证流程：</p>
<ol>
<li>查看公钥是否是私钥方的</li>
<li>然后用公钥对密文进行解密得到摘要</li>
<li>将APP用同样的摘要算法得到摘要，两个摘要进行比对，如果相等那么一切正常<br>以上过程只要有一步出问题就视为无效。</li>
</ol>
<hr>
<h4 id="include与-import的区别、-import与-class-的区别"><a href="#include与-import的区别、-import与-class-的区别" class="headerlink" title="#include与#import的区别、#import与@class 的区别"></a>#include与#import的区别、#import与@class 的区别</h4><p>#include和#import 其效果相同,都是导入类中定义的行为(方法);  </p>
<p>#import 不会引起交叉编译,确保头文件只会被导入一次；<br>@class 表明只定义了类的名称,而具体类的行为是未知的,一般用于.h 文件<br>@class比#import编译效率更高。此外@class和#import的主要区别在于解决引用死锁的问题。 </p>
<hr>
<h4 id="请分别说明-public、-protected、-private的含义与作用"><a href="#请分别说明-public、-protected、-private的含义与作用" class="headerlink" title="请分别说明@public、@protected、@private的含义与作用"></a>请分别说明@public、@protected、@private的含义与作用</h4><p>@public:对象的实例变量的作用域在任意地方都可以被访问 ;<br>@protected:对象的实例变量作用域在本类和子类都可以被访问 ;<br>@private:实例变量的作用域只能在本类(自身)中访问 .  </p>
<hr>
<h4 id="请解释self-super-init-方法"><a href="#请解释self-super-init-方法" class="headerlink" title="请解释self = [super init]方法"></a>请解释self = [super init]方法</h4><p>容错处理,当父类初始化失败,会返回一个nil,表示初始化失败。由于继承的关系,子类是需要拥有父类的实例和行为,因此,我们必须先初始化父类,然后再初始化子类  </p>
<hr>
<h4 id="什么情况使用-weak-关键字，相比-assign-有什么不同？"><a href="#什么情况使用-weak-关键字，相比-assign-有什么不同？" class="headerlink" title="什么情况使用 weak 关键字，相比 assign 有什么不同？"></a>什么情况使用 weak 关键字，相比 assign 有什么不同？</h4><p>什么情况使用 weak 关键字</p>
<ol>
<li>在 ARC 中,在有可能出现循环引用的时候,往往要通过让其中一端使用 weak 来解决,比如: delegate 代理属性</li>
<li>自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用 weak,自定义 IBOutlet 控件属性一般也使用 weak；当然，也可以使用strong。<br>不同点：</li>
<li>weak: 此特质表明该属性定义了一种“非拥有关系” (nonowning relationship)。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同assign类似， 然而在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。 而 assign<br>的“设置方法”只会执行针对“纯量类型” (scalar type，例如 CGFloat 或 NSlnteger 等)的简单赋值操作。</li>
<li>assigin 可以用非 OC 对象,而 weak 必须用于 OC 对象</li>
</ol>
<hr>
<h4 id="protocol-和-category-中如何使用-property"><a href="#protocol-和-category-中如何使用-property" class="headerlink" title="@protocol 和 category 中如何使用 @property"></a>@protocol 和 category 中如何使用 @property</h4><p>● 在 protocol 中使用 property 只会生成 setter 和 getter 方法声明,我们使用属性的目的,是希望遵守我协议的对象能实现该属性<br>● category 使用 @property 也是只会生成 setter 和 getter 方法的声明,如果我们真的需要给 category 增加属性的实现,需要借助于运行时的两个函数：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">objc_setAssociatedObject  </div><div class="line">objc_getAssociatedObject</div></pre></td></tr></table></figure>
<hr>
<h4 id="用-property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？"><a href="#用-property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？" class="headerlink" title="用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？"></a>用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？</h4><ol>
<li>因为父类指针可以指向子类对象,使用 copy 的目的是为了让本对象的属性不受外界影响,使用 copy 无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本.</li>
<li>如果我们使用是 strong ,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性.<br>copy 此特质所表达的所属关系与 strong 类似。然而设置方法并不保留新值，而是将其“拷贝” (copy)。 当属性类型为 NSString 时，经常用此特质来保护其封装性，因为传递给设置方法的新值有可能指向一个 NSMutableString 类的实例。这个类是 NSString 的子类，表示一种可修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时就要拷贝一份“不可变” (immutable)的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的” (mutable)，就应该在设置新属性值时拷贝一份。</li>
</ol>
<hr>
<h4 id="这个写法会出什么问题：-property-copy-NSMutableArray-array"><a href="#这个写法会出什么问题：-property-copy-NSMutableArray-array" class="headerlink" title="这个写法会出什么问题： @property (copy) NSMutableArray *array;"></a>这个写法会出什么问题： @property (copy) NSMutableArray *array;</h4><p>两个问题：</p>
<ol>
<li>添加,删除,修改数组内的元素的时候,程序会因为找不到对应的方法而崩溃.因为 copy 就是复制一个不可变 NSArray 的对象；</li>
<li>使用了 atomic 属性会严重影响性能 ；</li>
</ol>
<hr>
<h4 id="如何为-Class-定义一个对外只读对内可读写的属性"><a href="#如何为-Class-定义一个对外只读对内可读写的属性" class="headerlink" title="如何为 Class 定义一个对外只读对内可读写的属性?"></a>如何为 Class 定义一个对外只读对内可读写的属性?</h4><p>在头文件中将属性定义为readonly, 在.m文件中将属性重新定义为readwrite</p>
<hr>
<h4 id="为什么很多内置类如UITableViewController的delegate属性都是assign而不是retain的？"><a href="#为什么很多内置类如UITableViewController的delegate属性都是assign而不是retain的？" class="headerlink" title="为什么很多内置类如UITableViewController的delegate属性都是assign而不是retain的？"></a>为什么很多内置类如UITableViewController的delegate属性都是assign而不是retain的？</h4><p>所有的引用计数系统，都存在循环应用的问题。例如下面的引用关系：<br>• 对象a创建并引用到了对象b.<br>• 对象b创建并引用到了对象c.<br>• 对象c创建并引用到了对象b.这时候b和c的引用计数分别是2和1。  </p>
<blockquote>
<p>当a不再使用b，调用release释放对b的所有权，因为c还引用了b，所以b的引用计数为1，b不会被释放。b不释放，c的引用计数就是1，c也不会被释放。从此，b和c永远留在内存中。这种情况，必须打断循环引用，通过其他规则来维护引用关系。我们常见的delegate往往是assign方式的属性而不是retain方式 的属性，赋值不会增加引用计数，就是为了防止delegation两端产生不必要的循环引用。如果一个UITableViewController 对象a通过retain获取了UITableView对象b的所有权，这个UITableView对象b的delegate又是a， 如果这个delegate是retain方式的，那基本上就没有机会释放这两个对象了。自己在设计使用delegate模式时，也要注意这点。</p>
</blockquote>
<hr>
<h4 id="使用block有什么好处？请使用NSTimer写出一个使用block显示（在UILabel上）秒表的代码"><a href="#使用block有什么好处？请使用NSTimer写出一个使用block显示（在UILabel上）秒表的代码" class="headerlink" title="使用block有什么好处？请使用NSTimer写出一个使用block显示（在UILabel上）秒表的代码"></a>使用block有什么好处？请使用<code>NSTimer</code>写出一个使用block显示（在<code>UILabel</code>上）秒表的代码</h4><p>代码紧凑，传值、回调都很方便，省去了写代理的很多代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSTimer封装成的block，实现方法：</div><div class="line">NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:1.0 repeats:YES callback:^() &#123;</div><div class="line">weakSelf.secondsLabel.text = ...</div><div class="line">&#125;</div><div class="line">[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</div></pre></td></tr></table></figure>
<hr>
<h4 id="block和代理的区别，哪个更好？"><a href="#block和代理的区别，哪个更好？" class="headerlink" title="block和代理的区别，哪个更好？"></a>block和代理的区别，哪个更好？</h4><blockquote>
<p>代理回调更面向过程，block更面向结果。<br>如果需要在执行的不同步骤时被通知，你就要使用代理。<br>如果只需要请求的消息或者失败的详情，应该使用block。<br>block更适合与状态无关的操作，比如被告知某些结果.<br>block之间是不会相互影响的。<br>但是代理更像一个生产流水线，每个回调方法是生产线上的一个处理步骤，一个回调的变动可能会引起另一个回调的变动。要是一个对象有超过一个的不同事件，应该使用代理。<br>一个对象只有一个代理，要是某个对象是个单例对象，就不能使用代理。要是一个对象调用方法需要返回一些额外的信息，就可能需要使用代理。</p>
</blockquote>
<hr>
<h4 id="在block内如何修改block外部变量？"><a href="#在block内如何修改block外部变量？" class="headerlink" title="在block内如何修改block外部变量？"></a>在block内如何修改block外部变量？</h4><p>默认情况下，在block中访问的外部变量是复制过去的，即：写操作不对原变量生效。但是你可以加上__block来让其写操作生效，示例代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">__block int a = 0;</div><div class="line">void  (^foo)(void) = ^&#123;</div><div class="line">a = 1;</div><div class="line">&#125;</div><div class="line">f00();</div></pre></td></tr></table></figure>
<hr>
<h4 id="类别和类扩展的区别"><a href="#类别和类扩展的区别" class="headerlink" title="类别和类扩展的区别"></a>类别和类扩展的区别</h4><p>category和extensions的不同在于后者可以添加属性。另外后者添加的方法是必须要实现的。</p>
<h2 id="extensions可以认为是一个私有的Category。"><a href="#extensions可以认为是一个私有的Category。" class="headerlink" title="extensions可以认为是一个私有的Category。"></a>extensions可以认为是一个私有的Category。</h2><h4 id="分类的作用？分类和继承的区别？"><a href="#分类的作用？分类和继承的区别？" class="headerlink" title="分类的作用？分类和继承的区别？"></a>分类的作用？分类和继承的区别？</h4><ul>
<li>分类可以在不获悉，不改变原来代码的情况下往里面添加新的方法，只能添加，不能删除修改，并且如果分类和原来类中的方法产生名称冲突，则分类将覆盖原来的方法，因为分类具有更高的优先级。</li>
<li>继承可以增加，修改或者删除方法，并且可以增加属性；但是分类只能添加方法，不能删除修改，也不能增加属性。</li>
</ul>
<hr>
<h4 id="重写一个类的方法用继承好还是分类好-为什么"><a href="#重写一个类的方法用继承好还是分类好-为什么" class="headerlink" title="重写一个类的方法用继承好还是分类好? 为什么?"></a>重写一个类的方法用继承好还是分类好? 为什么?</h4><p>一般情况用分类好，用Category去重写类的方法，仅对本Category有效，不会影响到其他类与原有类的关系。</p>
<hr>
<h4 id="addObserver-forKeyPath-options-context-各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？"><a href="#addObserver-forKeyPath-options-context-各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？" class="headerlink" title="addObserver:forKeyPath:options:context:各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？"></a>addObserver:forKeyPath:options:context:各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// 添加键值观察</div><div class="line">/*</div><div class="line">1 观察者，负责处理监听事件的对象</div><div class="line">2 观察的属性</div><div class="line">3 观察的选项</div><div class="line">4 上下文</div><div class="line">*/</div><div class="line">[self.person addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:@&quot;Person Name&quot;];</div><div class="line">observer中需要实现一下方法：</div><div class="line">// 所有的 kvo 监听到事件，都会调用此方法</div><div class="line">/*</div><div class="line">1. 观察的属性</div><div class="line">2. 观察的对象</div><div class="line">3. change 属性变化字典（新／旧）</div><div class="line">4. 上下文，与监听的时候传递的一致</div><div class="line">*/</div><div class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context;</div></pre></td></tr></table></figure>
<hr>
<h4 id="若一个类有实例变量NSString-foo，调用setValue-forKey-时，可以以foo还是-foo作为key？"><a href="#若一个类有实例变量NSString-foo，调用setValue-forKey-时，可以以foo还是-foo作为key？" class="headerlink" title="若一个类有实例变量NSString *_foo，调用setValue:forKey:时，可以以foo还是_foo作为key？"></a>若一个类有实例变量NSString *_foo，调用setValue:forKey:时，可以以foo还是_foo作为key？</h4><p>都可以。 </p>
<hr>
<h4 id="KVC的keyPath中的集合运算符如何使用？"><a href="#KVC的keyPath中的集合运算符如何使用？" class="headerlink" title="KVC的keyPath中的集合运算符如何使用？"></a>KVC的keyPath中的集合运算符如何使用？</h4><ol>
<li>必须用在集合对象上或普通对象的集合属性上</li>
<li>简单集合运算符有@avg， @count ， @max ， @min ，@sum，</li>
<li>格式 @”@sum.age”或 @”集合属性.@max.age”</li>
</ol>
<hr>
<h4 id="KVC和KVO的keyPath一定是属性么？"><a href="#KVC和KVO的keyPath一定是属性么？" class="headerlink" title="KVC和KVO的keyPath一定是属性么？"></a>KVC和KVO的keyPath一定是属性么？</h4><p>KVO支持实例变量</p>
<h4 id="我们说的oc是动态运行时语言是什么意思"><a href="#我们说的oc是动态运行时语言是什么意思" class="headerlink" title="我们说的oc是动态运行时语言是什么意思?"></a>我们说的oc是动态运行时语言是什么意思?</h4><p>OC的动态运行时，是指OC具有动态类型和动态绑定的特性。动态类型能使程序直到执行时才确定对象的所属类， 其具体引用的对象在运行时才能确定。 动态绑定能使程序直到运行时才确定调用对象的实际方法。<br>多态。 主要是将数据类型的确定由编译时，推迟到了运行时。<br>这个问题其实浅涉及到两个概念，运行时和多态。<br>简单来说，运行时机制使我们直到运行时才去决定一个对象的类别，以及调用该类别对象指定方法。<br>多态：不同对象以自己的方式响应相同的消息的能力叫做多态。意思就是假设生物类(life)都用有一个相同的方法-eat;<br>那人类属于生物，猪也属于生物，都继承了life后，实现各自的eat，但是调用是我们只需调用各自的eat方法。<br>也就是不同的对象以自己的方式响应了相同的消息(响应了eat这个选择器)。<br>因此也可以说，运行时机制是多态的基础?~~~  </p>
<hr>
<h4 id="对于语句NSString-obj-NSData-alloc-init-obj在编译时和运行时分别时什么类型的对象"><a href="#对于语句NSString-obj-NSData-alloc-init-obj在编译时和运行时分别时什么类型的对象" class="headerlink" title="对于语句NSString*obj = [[NSData alloc] init]; obj在编译时和运行时分别时什么类型的对象?"></a>对于语句NSString*obj = [[NSData alloc] init]; obj在编译时和运行时分别时什么类型的对象?</h4><p>编译时是NSString的类型;运行时是NSData类型的对象</p>
<p>isMemberOfClass 和 isKindOfClass 联系与区别</p>
<ul>
<li>联系：两者都能检测一个对象是否是某个类的成员</li>
<li>区别：isKindOfClass不仅用来确定一个对象是否是一个类的成员,也可以用来确定一个对象是否派生自该类的类的成员 ,而isMemberOfClass 只能做到第一点。<br>举例：如 ClassA派 生 自NSObject 类 , ClassA *a = [ClassA alloc] init];,[a isKindOfClass:[NSObject class]] 可以检查出 a 是否是 NSObject派生类 的成员,但 isMemberOfClass 做不到。</li>
</ul>
<hr>
<h4 id="一个objc对象的isa的指针指向什么？有什么作用？"><a href="#一个objc对象的isa的指针指向什么？有什么作用？" class="headerlink" title="一个objc对象的isa的指针指向什么？有什么作用？"></a>一个objc对象的isa的指针指向什么？有什么作用？</h4><p>指向他的类对象,从而可以找到对象上的方法</p>
<p>objc中的类方法和实例方法有什么本质区别和联系？  </p>
<p>类方法：</p>
<ol>
<li>类方法是属于类对象的</li>
<li>类方法只能通过类对象调用</li>
<li>类方法中的self是类对象</li>
<li>类方法可以调用其他的类方法</li>
<li>类方法中不能访问成员变量</li>
<li>类方法中不定直接调用对象方法  </li>
</ol>
<p>实例方法：</p>
<ol>
<li>实例方法是属于实例对象的</li>
<li>实例方法只能通过实例对象调用</li>
<li>实例方法中的self是实例对象</li>
<li>实例方法中可以访问成员变量</li>
<li>实例方法中直接调用实例方法</li>
<li>实例方法中也可以调用类方法(通过类名)</li>
</ol>
<hr>
<h4 id="请描述一个你所遇到retain-cycle例子"><a href="#请描述一个你所遇到retain-cycle例子" class="headerlink" title="请描述一个你所遇到retain cycle例子"></a>请描述一个你所遇到retain cycle例子</h4><p>block中的循环引用一个ViewController</p>
<hr>
<h4 id="请谈谈内存的使用和优化的注意事项"><a href="#请谈谈内存的使用和优化的注意事项" class="headerlink" title="请谈谈内存的使用和优化的注意事项"></a>请谈谈内存的使用和优化的注意事项</h4><p>● <strong>重用问题</strong>：如UITableViewCells、UICollectionViewCells、UITableViewHeaderFooterViews设置正确的reuseIdentifier，充分重用；<br>● <strong>尽量把views设置为不透明</strong>：当opque为NO的时候，图层的半透明取决于图片和其本身合成的图层为结果，可提高性能；<br>● <strong>不要使用太复杂的XIB/Storyboard</strong>：载入时就会将XIB/storyboard需要的所有资源，包括图片全部载入内存，即使未来很久才会使用。那些相比纯代码写的延迟加载，性能及内存就差了很多；<br>● <strong>选择正确的数据结构</strong>：学会选择对业务场景最合适的数组结构是写出高效代码的基础。比如，数组:   有序的一组值。使用索引来查询很快，使用值查询很慢，插入/删除很慢。字典: 存储键值对，用键来查找比较快。集合: 无序的一组值，用值来查找很快，插入/删除很快。gzip/zip压缩：当从服务端下载相关附件时，可以通过gzip/zip压缩后再下载，使得内存更小，下载速度也更快。<br>● <strong>延迟加载</strong>：对于不应该使用的数据，使用延迟加载方式。对于不需要马上显示的视图，使用延迟加载方式。比如，网络请求失败时显示的提示界面，可能一直都不会使用到，因此应该使用延迟加载。<br>● <strong>数据缓存</strong>：对于cell的行高要缓存起来，使得reload数据时，效率也极高。而对于那些网络数据，不需要每次都请求的，应该缓存起来，可以写入数据库，也可以通过plist文件存储。<br>● <strong>处理内存警告</strong>：一般在基类统一处理内存警告，将相关不用资源立即释放掉重用大开销对象：一些objects的初始化很慢，比如NSDateFormatter<br>和NSCalendar<br>，但又不可避免地需要使用它们。通常是作为属性存储起来，防止反复创建。<br>● <strong>避免反复处理数据</strong>：许多应用需要从服务器加载功能所需的常为JSON或者XML格式的数据。在服务器端和客户端使用相同的数据结构很重要;<br>● <strong>使用Autorelease   Pool</strong>：在某些循环创建临时变量处理数据时，自动释放池以保证能及时释放内存;<br>● <strong>正确选择图片加载方式</strong>：详情阅读UIImage加载方式  </p>
<hr>
<h4 id="线程与进程的区别和联系"><a href="#线程与进程的区别和联系" class="headerlink" title="线程与进程的区别和联系?"></a>线程与进程的区别和联系?</h4><ol>
<li>一个程序至少要有进程,一个进程至少要有一个线程.</li>
<li>进程:资源分配的最小独立单元,进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.</li>
<li>线程:进程下的一个分支,是进程的实体,是CPU调度和分派的基本单元,它是比进程更小的能独立运行的基本单位,线程自己基本不拥有系统资源,只拥有一点在运行中必不可少的资源(程序计数器、一组寄存器、栈)，但是它可与同属一个进程的其他线程共享进程所拥有的全部资源。</li>
<li>进程和线程都是由操作系统所体会的程序运行的基本单元，系统利用该基本单元实现系统对应用的并发性。</li>
<li>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。</li>
<li>但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</li>
</ol>
<hr>
<h4 id="请简单介绍下iOS的多线程"><a href="#请简单介绍下iOS的多线程" class="headerlink" title="请简单介绍下iOS的多线程"></a>请简单介绍下iOS的多线程</h4><p>iOS中的多线程，是Cocoa框架下的多线程，通过Cocoa的封装，可以让我们更为方便的使用线程，做过C++的同学可能会对线程有更多的理解，比如线程的创立，信号量、共享变量有认识，Cocoa框架下会方便很多，它对线程做了封装，有些封装，可以让我们创建的对象，本身便拥有线程，也就是线程的对象化抽象，从而减少我们的工程，提供程序的健壮性。  </p>
<p><strong>GCD</strong><br>GCD是(Grand Central Dispatch)的缩写 ，从系统级别提供的一个易用地多线程类库，具有运行时的特点，能充分利用多核心硬件。GCD的API接口为C语言的函数，函数参数中多数有Block, 为我们提供强大的“接口”。<br><strong>NSOperation与Queue</strong><br>NSOperation是一个抽象类，它封装了线程的细节实现，我们可以通过子类化该对象，加上NSQueue来同面向对象的思维，管理多线程程序。<br><strong>NSThread</strong><br>NSThread是一个控制线程执行的对象，它不如NSOperation抽象，通过它我们可以方便的得到一个线程，并控制它。但NSThread的线程之间的并发控制，是需要我们自己来控制的，可以通过NSCondition实现。</p>
<p><img src="http://or4nzqs8b.bkt.clouddn.com/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A1%86%E6%9E%B6%E5%9B%BE.png" alt="image"></p>
<hr>
<h4 id="什么时候选择NSOperation-NSOperation-相比于-GCD-有哪些优势？"><a href="#什么时候选择NSOperation-NSOperation-相比于-GCD-有哪些优势？" class="headerlink" title="什么时候选择NSOperation? NSOperation 相比于 GCD 有哪些优势？"></a>什么时候选择NSOperation? NSOperation 相比于 GCD 有哪些优势？</h4><p>项目中使用NSOperation的优点是NSOperation是对线程的高度抽象，在项目中使用它，会使项目的程序结构更好，子类化NSOperation的设计思路，是具有面向对象的优点(复用、封装)，使得实现是多线程支持，而接口简单，建议在复杂项目中使用。<br>● 提供了在 GCD 中不那么容易复制的有用特性。<br>● 提供了任务的状态：isExecuteing, isFinished, 可以很方便的取消一个NSOperation的执行<br>● 可以更容易的添加任务的依赖关系<br>项目中使用GCD的优点是GCD本身非常简单、易用，对于不复杂的多线程操作，会节省代码量，而Block参数的使用，会是代码更为易读，建议在简单项目中使用。</p>
<hr>
<h4 id="使用atomic一定是线程安全的吗？"><a href="#使用atomic一定是线程安全的吗？" class="headerlink" title="使用atomic一定是线程安全的吗？"></a>使用atomic一定是线程安全的吗？</h4><p>不是，atomic的本意是指属性的存取方法是线程安全的（thread safe)，并不保证整个对象是线程安全的。比如，声明一个NSMutableArray的原子属性stuff，此时self.stuff 和self.stuff = othersulf都是线程安全的。但是，使用[self.stuff objectAtIndex:index]就不是线程安全的，需要用锁来保证线程安全性。</p>
<hr>
<h4 id="GCD的队列（dispatch-queue-t）分哪两种类型？"><a href="#GCD的队列（dispatch-queue-t）分哪两种类型？" class="headerlink" title="GCD的队列（dispatch_queue_t）分哪两种类型？"></a>GCD的队列（dispatch_queue_t）分哪两种类型？</h4><ol>
<li>串行队列Serial Dispatch Queue</li>
<li>并行队列Concurrent Dispatch Queue</li>
</ol>
<hr>
<h4 id="dispatch-barrier-async的作用是什么？"><a href="#dispatch-barrier-async的作用是什么？" class="headerlink" title="dispatch_barrier_async的作用是什么？"></a>dispatch_barrier_async的作用是什么？</h4><p>在并行队列中，为了保持某些任务的顺序，需要等待一些任务完成后才能继续进行，使用 barrier 来等待之前任务完成，避免数据竞争等问题。  </p>
<p>dispatch_barrier_async 函数会等待追加到Concurrent Dispatch Queue并行队列中的操作全部执行完之后，然后再执行 dispatch_barrier_async 函数追加的处理，等 dispatch_barrier_async 追加的处理执行结束之后，Concurrent Dispatch Queue才恢复之前的动作继续执行。  </p>
<p>打个比方：比如你们公司周末跟团旅游，高速休息站上，司机说：大家都去上厕所，速战速决，上完厕所就上高速。超大的公共厕所，大家同时去，程序猿很快就结束了，但程序媛就可能会慢一些，即使你第一个回来，司机也不会出发，司机要等待所有人都回来后，才能出发。 dispatch_barrier_async 函数追加的内容就如同 “上完厕所就上高速”这个动作。</p>
<blockquote>
<p>（注意：使用 dispatch_barrier_async ，该函数只能搭配自定义并行队列 dispatch_queue_t 使用。不能使用： dispatch_get_global_queue ，否则 dispatch_barrier_async 的作用会和 dispatch_async 的作用一模一样。 ）</p>
</blockquote>
<hr>
<h4 id="UITableViewCell上有个UILabel，显示NSTimer实现的秒表时间，手指滚动cell过程中，label是否刷新，为什么？"><a href="#UITableViewCell上有个UILabel，显示NSTimer实现的秒表时间，手指滚动cell过程中，label是否刷新，为什么？" class="headerlink" title="UITableViewCell上有个UILabel，显示NSTimer实现的秒表时间，手指滚动cell过程中，label是否刷新，为什么？"></a>UITableViewCell上有个UILabel，显示NSTimer实现的秒表时间，手指滚动cell过程中，label是否刷新，为什么？</h4><p>这是否刷新取决于timer加入到Run Loop中的Mode是什么。Mode主要是用来指定事件在运行循环中的优先级的，分为：<br>● NSDefaultRunLoopMode（kCFRunLoopDefaultMode）：默认，空闲状态<br>● UITrackingRunLoopMode：ScrollView滑动时会切换到该Mode<br>● UIInitializationRunLoopMode：run loop启动时，会切换到该Mode<br>● NSRunLoopCommonModes（kCFRunLoopCommonModes）：</p>
<p>苹果公开提供的Mode有两个：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSDefaultRunLoopMode（kCFRunLoopDefaultMode）  </div><div class="line">NSRunLoopCommonModes（kCFRunLoopCommonModes）</div></pre></td></tr></table></figure>
<blockquote>
<p>在编程中：如果我们把一个NSTimer对象以NSDefaultRunLoopMode添加到主运行循环中的时候, ScrollView滚动过程中会因为Mode的切换，而导致NSTimer将不再被调度。当我们滚动的时候，也希望不调度，那就应该使用默认模式。但是，如果希望在滚动时，定时器也要回调，那就应该使用NSRunLoopCommonModes</p>
</blockquote>
<hr>
<h4 id="runtime-如何实现-weak-属性"><a href="#runtime-如何实现-weak-属性" class="headerlink" title="runtime 如何实现 weak 属性"></a>runtime 如何实现 weak 属性</h4><p>runtime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时候会 dealloc，假如 weak 指向的对象内存地址是a，那么就会以a为键， 在这个 weak 表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil。</p>
<hr>
<h4 id="runtime如何通过selector找到对应的IMP地址？"><a href="#runtime如何通过selector找到对应的IMP地址？" class="headerlink" title="runtime如何通过selector找到对应的IMP地址？"></a>runtime如何通过selector找到对应的IMP地址？</h4><p>每一个类对象中都一个方法列表,方法列表中记录着方法的名称,方法实现,以及参数类型,其实selector本质就是方法名称,通过这个方法名称就可以在方法列表中找到对应的方法实现.</p>
<hr>
<h4 id="void-load-void-initialize；有什么用处？"><a href="#void-load-void-initialize；有什么用处？" class="headerlink" title="+(void)load; +(void)initialize；有什么用处？"></a>+(void)load; +(void)initialize；有什么用处？</h4><p>在Objective-C中，runtime会自动调用每个类的两个方法。+load会在类初始加载时调用，+initialize会在第一次调用类的类方法或实例方法之前被调用。这两个方法是可选的，且只有在实现了它们时才会被调用。</p>
<hr>
<h4 id="如何访问并修改一个类的私有属性？"><a href="#如何访问并修改一个类的私有属性？" class="headerlink" title="如何访问并修改一个类的私有属性？"></a>如何访问并修改一个类的私有属性？</h4><p><strong>方法一:KVC(键值编码)</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Person *p = [Person new];</div><div class="line">//修改私有属性的值</div><div class="line">[p setValue:@&quot;yyMae&quot; forKey:@&quot;name&quot;];</div><div class="line">//访问私有属性的值</div><div class="line">NSString *name = [p valueForKey:@&quot;name&quot;];</div></pre></td></tr></table></figure>
<p><strong>方法二:通过runtime获取或修改一个类私有属性的值</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Person *p = [Person new];</div><div class="line">// IVar是runtime声明的一个宏</div><div class="line">unsigned int count = 0; //count记录变量的数量</div><div class="line">// 获取类的所有属性变量</div><div class="line">Ivar *members = class_copyIvarList([Person class], &amp;count);</div><div class="line">for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">Ivar ivar = members[i];</div><div class="line">// 取得属性名并转成字符串类型</div><div class="line">const char *memberName = ivar_getName(ivar);</div><div class="line">NSLog(@&quot;%s&quot;,memberName);</div><div class="line">Ivar name = members[0];</div><div class="line">// 修改属性值</div><div class="line">object_setIvar(Person, name, @&quot;yyMae&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h4 id="Objective-C-如何对已有的方法，添加自己的功能代码以实现类似记录日志这样的功能？"><a href="#Objective-C-如何对已有的方法，添加自己的功能代码以实现类似记录日志这样的功能？" class="headerlink" title="Objective-C 如何对已有的方法，添加自己的功能代码以实现类似记录日志这样的功能？"></a>Objective-C 如何对已有的方法，添加自己的功能代码以实现类似记录日志这样的功能？</h4><p>这题目主要考察的是runtime如何交换方法  </p>
<p>先在分类中添加一个方法,注意不能重写系统方法,会覆盖先在分类中添加一个方法,注意不能重写系统方法,会覆盖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">+ (NSString *)myLog</div><div class="line">&#123;</div><div class="line">// 这里写打印行号,什么方法,哪个类调用等等</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后交换方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 加载分类到内存的时候调用</div><div class="line">+ (void)load</div><div class="line">&#123;</div><div class="line">// 获取description方法地址</div><div class="line">Method description = class_getClassMethod(self, @selector(description));</div><div class="line"></div><div class="line">// 获取myLog方法地址</div><div class="line">Method myLog = class_getClassMethod(self, @selector(myLog));</div><div class="line"></div><div class="line">// 交换方法地址，相当于交换实现方式</div><div class="line">method_exchangeImplementations(description, myLog);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下回调用description方法时，实际上调用的是myLog的方法。</p>
<hr>
<h4 id="Splitview-Controller是什么？"><a href="#Splitview-Controller是什么？" class="headerlink" title="Splitview Controller是什么？"></a>Splitview Controller是什么？</h4><p>UISplitViewController适合用于主从界面的情况（Master view→Detail view），Detail view跟随Master view进行更新。</p>
<hr>
<h4 id="AppDelegate扮演着什么样的角色？"><a href="#AppDelegate扮演着什么样的角色？" class="headerlink" title="AppDelegate扮演着什么样的角色？"></a>AppDelegate扮演着什么样的角色？</h4><p>创建应用程序之后之后，默认有AppDelegate.h文件与AppDelegate.m文件。<br>AppDelegate为整个应用的一个代理，提供程序启动、退出等类似监控的接口，控制着应用的生命周期。</p>
<hr>
<h4 id="请谈谈应用的生命周期"><a href="#请谈谈应用的生命周期" class="headerlink" title="请谈谈应用的生命周期"></a>请谈谈应用的生命周期</h4><ol>
<li>启动程序</li>
</ol>
<ul>
<li>willFinishLaunchingWithOptions</li>
<li>didFinishLaunchingWithOptions</li>
<li>applicationDidBecomeActive</li>
</ul>
<ol>
<li>按下home键</li>
</ol>
<ul>
<li>applicationWillResignActive</li>
<li>applicationDidEnterBackground</li>
</ul>
<ol>
<li>双击home键，再打开程序</li>
</ol>
<ul>
<li>applicationWillEnterForeground</li>
<li>applicationDidBecomeActive</li>
</ul>
<ol>
<li>当程序将要退出是被调用，通常是用来保存数据</li>
</ol>
<ul>
<li>applicationWillTerminate</li>
</ul>
<hr>
<h4 id="当系统出现内存警告时会发生什么？"><a href="#当系统出现内存警告时会发生什么？" class="headerlink" title="当系统出现内存警告时会发生什么？"></a>当系统出现内存警告时会发生什么？</h4><ul>
<li>会将不在当前窗口上的view暂时移除</li>
<li>如果放任内存警告,最终会导致软件强制被系统关闭</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/10/浅谈IOS中strong、weak、assign、retain及copy关键字的使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="行走的风车">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Windmill's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/10/浅谈IOS中strong、weak、assign、retain及copy关键字的使用/" itemprop="url">浅谈IOS中strong、weak、assign、retain及copy关键字的使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-10T16:07:01+08:00">
                2017-06-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><p>在Xcode4.1之前iOS内存管理只有MRC模式，即手动内存管理，此时创建的对象需要手动release&amp;dealloc，在4.1之后出现了ARC模式，由系统来自动管理内存的使用。没有接触过MRC编程的同学可能就不了解assign、retain、copy这三个关键词，strong、weak这两个关键词是在ARC模式中提出的，相比而言，weak相当于老版本的assign（基本一致），strong相当于retain（一致）。</p>
<h1 id="MRC"><a href="#MRC" class="headerlink" title="MRC"></a>MRC</h1><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>在ObjC中每个对象内部都有一个与之对应的整数（retainCount），叫“引用计数器”，当一个对象在创建之后它的引用计数器为1，当调用这个对象的alloc、retain、new、copy方法之后引用计数器自动在原来的基础上加1（ObjC中调用一个对象的方法就是给这个对象发送一个消息），当调用这个对象的release方法之后它的引用计数器减1，如果一个对象的引用计数器为0，则系统会自动调用这个对象的dealloc方法来销毁这个对象。</p>
<p><strong>比较</strong></p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>引用计数</th>
<th>set方法处理</th>
</tr>
</thead>
<tbody>
<tr>
<td>assign</td>
<td>不变</td>
<td>直接赋值</td>
</tr>
<tr>
<td>retain</td>
<td>＋1</td>
<td>先release原来到值，再retain新值</td>
</tr>
<tr>
<td>copy</td>
<td>＋1</td>
<td>先release原来到值，再copy新值</td>
</tr>
</tbody>
</table>
<p>对于设置了关键字的属性a：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic,关键字) NSObject *a;</div></pre></td></tr></table></figure></p>
<p>当使用了不同的关键字后自动实现的set方法：</p>
<h3 id="assign"><a href="#assign" class="headerlink" title="assign"></a>assign</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-(void)setA:(int)a&#123;</div><div class="line">    _a=a;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="retain"><a href="#retain" class="headerlink" title="retain"></a>retain</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">-(void)setA:(Car *)a&#123;</div><div class="line">    if(_a!=a)&#123;</div><div class="line">        [_a release];</div><div class="line">        _a=[a retain];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">-(void)setA:(NSString *)a&#123;</div><div class="line">    if(_a!=a)&#123;</div><div class="line">        [_a release];</div><div class="line">        _a=[a copy];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="深拷贝-mutableCopy-和浅拷贝-copy-："><a href="#深拷贝-mutableCopy-和浅拷贝-copy-：" class="headerlink" title="深拷贝(mutableCopy)和浅拷贝(copy)："></a>深拷贝(mutableCopy)和浅拷贝(copy)：</h2><p>深拷贝就是<strong>内容拷贝</strong>，浅拷贝就是<strong>指针拷贝</strong>。</p>
<h3 id="copy-vs-retain"><a href="#copy-vs-retain" class="headerlink" title="copy vs retain"></a>copy vs retain</h3><p>　　retain和strong都是指针拷贝。当有其他对象引用当前对象时，会拷贝一份当前对象的地址，这样它就也指向当前对象了。所以，还是同一个对象，只是retainCount+1；</p>
<p><strong>copy</strong>:对于不可变对象copy采用的是浅复制，引用计数器加1（其实这是编译器进行了优化，既然原来的对象不可变，复制之后的对象也不可变那么就没有必要再重新创建一个对象了）；对于可变对象copy采用的是深复制，引用计数器不变（原来的对象是可变，现在要产生一个不可变的当然得重新产生一个对象）；<br>浅复制如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSString *str1 = @&quot;123&quot;;</div><div class="line">NSString *str2 = [str1 copy];</div></pre></td></tr></table></figure></p>
<h1 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h1><p>　　ARC是自iOS 5之后增加的新特性，完全消除了手动管理内存的烦琐，编译器会自动在适当的地方插入适当的retain、release、autorelease语句。你不再需要担心内存管理,因为编译器为你处理了一切。</p>
<h2 id="强引用和弱引用"><a href="#强引用和弱引用" class="headerlink" title="强引用和弱引用"></a>强引用和弱引用</h2><p><strong>强引用</strong>：当前对象被其他对象引用时，会执行retain操作，引用计数器+1。当retainCount=0时，该对象才会被销毁。因为我们要进行对象的内存管理，所以这是默认的引用方式。（默认是强引用）</p>
<p><strong>弱引用</strong>：当前对象的生命周期不被是否由其他对象引用限制，它本该什么时候销毁就什么时候被销毁。即使它的引用没断，但是当它的生存周期到了时就会被销毁。</p>
<p>　　在定义属性时，若声明为retain类型的，则就是强引用；若声明为assign类型的，则就是弱引用。后来内存管理都由ARC来完成后，若是强引用，则就声明为strong；若是弱引用，则就声明为weak。</p>
<p>　　所以说，retain和strong是一致的（声明为强引用）；assign和weak是基本一致的（声明为弱引用）。之所以说它俩是基本一致是因为它俩还是有所不同的，weak严格的说应当叫“归零弱引用”，即当对象被销毁后，会自动的把它的指针置为nil，这样可以防止野指针错误。而assign销毁对象后不会把该对象的指针置nil，对象已经被销毁，但指针还在痴痴的指向它，这就成了野指针，这是比较危险的。</p>
<h2 id="深入理解："><a href="#深入理解：" class="headerlink" title="深入理解："></a>深入理解：</h2><ol>
<li>(weak与strong)不同的是：当一个对象不再有strong类型的指针指向它的时候，它就会被释放，即使改对象还有_weak类型的指针指向它；</li>
<li>一旦最后一个指向该对象的strong类型的指针离开，这个对象将被释放，如果这个时候还有weak指针指向该对象，则会清除掉所有剩余的weak指针</li>
</ol>
<h3 id="打个比方："><a href="#打个比方：" class="headerlink" title="打个比方："></a>打个比方：</h3><p>一个对象类比为<strong>一条狗</strong>，  <strong>释放对象</strong> 类比为 <strong>狗要跑掉</strong></p>
<p>逻辑如下：</p>
<blockquote>
<p>strong类型的指针就像是栓住的狗，只要你用绳子拴住狗，那么狗就不会跑掉.</p>
<p><strong>类比</strong> </p>
<p>一个对象 new过以后，不会自动的释放</p>
<p>如果有5个人都牵着这一条狗(5条绳子栓一只狗) </p>
<p><strong>类比为</strong> </p>
<p>5个strong类型指针指向一个对象.</p>
<p>除非5个绳子都脱落，否则狗是不会跑掉的，类比，5个strong指针都=nil，则该对象释放</p>
<p>weak型指针就像是一个小孩子指着狗喊道：“看，有一只狗在那里”，只要狗一直被拴着，那么小孩子就能看到狗 （weak指针）会一直指向它，只要狗的绳子脱落，那么狗就会跑掉，不管有多少的小孩在看着它。</p>
</blockquote>
<h2 id="避免“强引用循环“的僵局："><a href="#避免“强引用循环“的僵局：" class="headerlink" title="避免“强引用循环“的僵局："></a>避免“强引用循环“的僵局：</h2><p>　　默认的引用方式是强引用，但上面说了有时我们还得使用弱引用，那是什么情况呢？</p>
<p>　　答案，强引用循环：A对象强引用了B对象，B对象也强引用了A。因为都是强引用，也就是无论是A是B都要在对方的引用断了后才能销毁，但要断了引用，就必须对方对象销毁。就会出现这种僵局，为了避免出现这种情况，就应该有一个对象“示弱”，使其为“弱引用”。</p>
<p>　　比较常见的，视图中的父子视图之间的引用：父视图强引用子视图，子视图弱引用父视图。</p>
<h3 id="总结：由于要进行内存管理的缘故，OC里的引用默认都是强引用，但为了避免出现”强引用循环僵局“，所以有了弱引用（assign）。"><a href="#总结：由于要进行内存管理的缘故，OC里的引用默认都是强引用，但为了避免出现”强引用循环僵局“，所以有了弱引用（assign）。" class="headerlink" title="总结：由于要进行内存管理的缘故，OC里的引用默认都是强引用，但为了避免出现”强引用循环僵局“，所以有了弱引用（assign）。"></a>总结：由于要进行内存管理的缘故，OC里的引用默认都是强引用，但为了避免出现”强引用循环僵局“，所以有了弱引用（assign）。</h3>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="行走的风车" />
          <p class="site-author-name" itemprop="name">行走的风车</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">行走的风车</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

  

</body>
</html>
